CMPUT313 lab1
Bowei Wang 1462495
part1:
1.
typedef struct {
CnetNodetype node_t; // node type, e.g., NT_ROUTER
CnetTimer mytimer; // a timer identifier
CnetAddr src, dest; // user defined node addresses (not node numbers)
int ap_pos; // the (x,y,z)-coordinates of an access point
unsigned short code; // stores the return value of function CNET_ccitt()
} PACKET;

2.
we can call the global integer variable "nodeinfo.time_in_usec" to get time.
CnetTime is a 64-bit integer so we can use this instruction to print time.
Long value = node info.time_in_usec;
printf("time = %lld usecs\n", value);

3q1.
the default will give value: delta = 213714
reason:
we have 
minmessagesize           = 48bytes
wan-bandwidth            = 56000bps
wan-propagationdelay     = 100000usec
in topology file.
we can calculate the time delay for each message with the smallest size:
time = L/R + propagation delay 
48*8/56000 +100000 = 106857 usec for one way
106857*2 = 213714 usec for two ways
That is the reason why we get 213714.

q2. we can just change propagationdelay to 746571 usec to make delta approximately equal to 1.5.
second.

4.
can be different.
sizeof(f) will get the size of the structure f.
However FRAME_SIZE(f) is FRAME_HEADER_SIZE + f.len which is different from just size of frame.

5.
the value for CNET_IP_checksum( msg_1, 6)) is 65475
the value for CNET_IP_checksum( msg_2, 6)) is 65445
6.
"we can get an accurate and immediate report on the location (source file, function name, line number, and nodename) and type of each error."by using the CHECK macro.
(from http://www.csse.uwa.edu.au/cnet/faq.html)

The function check is like this:
#define CHECK(call)     do{ if(call) != 0) \
                        CNET_exit(__FILE__, __func__, __LINE__);} while(false)
If unexpected event happens, the called function will return -1 and check will get it for further handle.
while error happens, check will call  CNET_exit(__FILE__, (char *)NULL, __LINE__);
this instruction will exit cnet and "display the invoking node's name, source file, function, and line where it was called, together with the latest cnet_errno value"
(from http://cs.carleton.edu/faculty/jondich/courses/cs337_w00/Documents/cnetdoc/cnet.h)

By checking CNET_write_physical with a invalid link ,we can get an error information like this:
"Error @2506856usec while executing perth, file ping-W18.c, line 72, function physical_ready() ER_BADLINK: Invalid link number passed to a function."

7.
The protocol uses a checksum:
Initialize checksum at here:
    f.checksum  = CNET_ccitt((unsigned char *)&f, (int)length);
Then compare the checksum in process and saved checksum
    if(CNET_ccitt((unsigned char *)&f, (int)len) != checksum) {
        printf("\t\t\t\tBAD checksum - frame ignored\n");
        return;           // bad checksum, ignore frame
    }


Program report for part 2:
Two asked aspects:
1.Whether a node can identify its neighbours when the probframecorrupt for the
links is not zero.
No, the address of the corresponding neighbours will be some invalid numbers (like -324132) if a Frame is corrupt. Although we can still get the name, the address we get is invalid.

2. Whether the developed protocol produces logical or runtime errors when run on files
LAB1 T2 (a LAN) and LAB1 T3 (a WLAN).
There are some logical errors while running on Lab1 T2 and Lab1 T3.
A node won’t connect to any fix nodes. The connection is always change. The possible reason is that in T1, all the connections are links. However in T2 and T3, the connections are Lans and Wlans. These are not what we want to handle in our program.

Design Overview:
Define several variables:
int hello_num for number of hello received.
int ackhello_num for number of ack_hello sent.
int readylink for how many links that already has backward message.
char names[32][10] to save neighbour names.
int addresses[32] to save neighbour address.

In the function EVENT_HANDLER(button_pressed), add some information that should be printed.
This function will also check whether the number of links is over 32. If so, print a notice.
While printing links, use for loop to print all the list with information and check print number by readylink.

In the function EVENT_HANDLER(physical_ready):
Add some more information in f while receiving Hello. Get information in Hello_ack, save name in names[32], save address in address[32], update readylink.

In the function EVENT_HANDLER(timer1_send_hello):
Define a new variable max_possible. This variable is to save number of valid links to this  node.
Use a for loop to send message to all neighbours. The if statement is to check whether the next link is valid. If so, go to next loop, if not, make max_possible smaller so that the node won’t send message to a invalid link.

Program Status:
Currently the program can handle maximum 32 neighbours for a single node.This program is only for link. Not working for either Wlan or Lan.
The first difficulty I met is I don’t know how does the hello and hello_ack works. I read the program and think for a while. I changed something and found how does the Hello and Hello_ack works.
Another difficulty is I don’t know how to connect to multiple links at first. I tried to use link + 1 and found something new. Then I know how to achieve that.

Testing and Results:
For LAB1_T1.txt works good.   For LAB1_T2.txt and LAB1_T3.txt not works.
Tried a case that a node has over 32 neighbours. The program will print an error message if DEBUG0 is pressed.

Possible API errors: link error,CHECK( CNET_write_physical(link + i, (char *) &f, &len)) can case an error if a link + i is over the valid link number.

Acknowledgments sources of assistance:
http://cs.carleton.edu/faculty/jondich/courses/cs337_w00/Documents/cnetdoc/cnet.h
http://www.csse.uwa.edu.au/cnet/faq.html

